
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>leveldb: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ebanfa/skeleton-staging/internal/infrastructure/storage/leveldb/leveldb_database.go (56.5%)</option>
				
				<option value="file1">github.com/ebanfa/skeleton-staging/internal/infrastructure/storage/leveldb/leveldb_engine.go (89.7%)</option>
				
				<option value="file2">github.com/ebanfa/skeleton-staging/internal/infrastructure/storage/leveldb/leveldb_transaction.go (93.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package leveldb provides a LevelDB implementation of the storage interfaces.
package leveldb

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "sync"

        "github.com/ebanfa/skeleton-staging/internal/domain/component"
        "github.com/ebanfa/skeleton-staging/internal/domain/storage"
        "github.com/ebanfa/skeleton-staging/internal/infrastructure/storage/engine"
        "github.com/syndtr/goleveldb/leveldb"
        "github.com/syndtr/goleveldb/leveldb/errors"
        "github.com/syndtr/goleveldb/leveldb/filter"
        "github.com/syndtr/goleveldb/leveldb/iterator"
        "github.com/syndtr/goleveldb/leveldb/opt"
        "github.com/syndtr/goleveldb/leveldb/util"
)

const (
        // Version metadata key
        versionKey = "current_version"

        // Version directory name
        versionDirName = "versions"

        // Version key prefix for storing version data
        versionKeyPrefix = "v:"
)

// LevelDBDatabase implements the Database interface using LevelDB
type LevelDBDatabase struct {
        *storage.BaseDatabase
        db          *leveldb.DB
        config      *engine.LevelDBConfig
        versionPath string
        mutex       sync.RWMutex
}

// NewLevelDBDatabase creates a new LevelDB database
func NewLevelDBDatabase(id, name, path string, config *engine.LevelDBConfig) (*LevelDBDatabase, error) <span class="cov8" title="1">{
        // Create directories if they don't exist
        if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create database directory: %w", err)
        }</span>

        <span class="cov8" title="1">versionPath := filepath.Join(path, versionDirName)
        if err := os.MkdirAll(versionPath, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create version directory: %w", err)
        }</span>

        // Configure LevelDB options
        <span class="cov8" title="1">options := &amp;opt.Options{
                BlockSize:              config.BlockSize,
                BlockCacheCapacity:     config.BlockCache,
                WriteBuffer:            config.WriteBufferSize,
                Filter:                 filter.NewBloomFilter(10),
                DisableSeeksCompaction: false,
                Compression:            opt.DefaultCompression,
        }

        if config.DisableCompression </span><span class="cov8" title="1">{
                options.Compression = opt.NoCompression
        }</span>

        // Open the database
        <span class="cov8" title="1">db, err := leveldb.OpenFile(path, options)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsCorrupted(err) </span><span class="cov8" title="1">{
                        // Try to recover if the database is corrupted
                        db, err = leveldb.RecoverFile(path, options)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to recover corrupted database: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("failed to open database: %w", err)
                }</span>
        }

        // Create the database instance
        <span class="cov8" title="1">levelDB := &amp;LevelDBDatabase{
                BaseDatabase: storage.NewBaseDatabase(id, name, path),
                db:           db,
                config:       config,
                versionPath:  versionPath,
        }

        return levelDB, nil</span>
}

// OpenLevelDBDatabase opens an existing LevelDB database
func OpenLevelDBDatabase(id, name, path string) (*LevelDBDatabase, error) <span class="cov8" title="1">{
        // Check if path exists
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("database path does not exist: %s", path)
        }</span>

        // Use default config for opening
        <span class="cov8" title="1">config := engine.NewDefaultLevelDBConfig()
        return NewLevelDBDatabase(id, name, path, config)</span>
}

// Initialize initializes the database
func (db *LevelDBDatabase) Initialize(ctx component.Context) error <span class="cov8" title="1">{
        if err := db.BaseDatabase.Initialize(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Try to load the current version from metadata
        <span class="cov8" title="1">versionData, err := db.db.Get([]byte(versionKey), nil)
        if err == nil </span><span class="cov8" title="1">{
                // Parse version
                version, err := binary.ReadVarint(bytes.NewReader(versionData))
                if err == nil </span><span class="cov8" title="1">{
                        db.SetVersion(version)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Dispose closes the database
func (db *LevelDBDatabase) Dispose() error <span class="cov8" title="1">{
        db.mutex.Lock()
        defer db.mutex.Unlock()

        if db.db != nil </span><span class="cov8" title="1">{
                if err := db.db.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error closing LevelDB: %w", err)
                }</span>
                <span class="cov8" title="1">db.db = nil</span>
        }

        <span class="cov8" title="1">return db.BaseDatabase.Dispose()</span>
}

// Get retrieves a value from the database
func (db *LevelDBDatabase) Get(key []byte) ([]byte, error) <span class="cov8" title="1">{
        if !db.IsOpen() </span><span class="cov8" title="1">{
                return nil, storage.NewStorageError(
                        storage.ErrDatabaseClosed,
                        "database is closed",
                        map[string]interface{}{"database": db.ID()},
                        nil,
                )
        }</span>

        <span class="cov8" title="1">value, err := db.db.Get(key, nil)
        if err != nil </span><span class="cov8" title="1">{
                if err == leveldb.ErrNotFound </span><span class="cov8" title="1">{
                        return nil, storage.NewStorageError(
                                storage.ErrKeyNotFound,
                                "key not found",
                                map[string]interface{}{"key": string(key)},
                                nil,
                        )
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error getting key from LevelDB: %w", err)</span>
        }

        <span class="cov8" title="1">return value, nil</span>
}

// Set stores a key-value pair
func (db *LevelDBDatabase) Set(key, value []byte) error <span class="cov8" title="1">{
        if !db.IsOpen() </span><span class="cov8" title="1">{
                return storage.NewStorageError(
                        storage.ErrDatabaseClosed,
                        "database is closed",
                        map[string]interface{}{"database": db.ID()},
                        nil,
                )
        }</span>

        <span class="cov8" title="1">if key == nil || len(key) == 0 </span><span class="cov8" title="1">{
                return storage.NewStorageError(
                        storage.ErrInvalidKey,
                        "key cannot be nil or empty",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">err := db.db.Put(key, value, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error setting key in LevelDB: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete removes a key-value pair
func (db *LevelDBDatabase) Delete(key []byte) error <span class="cov8" title="1">{
        if !db.IsOpen() </span><span class="cov8" title="1">{
                return storage.NewStorageError(
                        storage.ErrDatabaseClosed,
                        "database is closed",
                        map[string]interface{}{"database": db.ID()},
                        nil,
                )
        }</span>

        <span class="cov8" title="1">err := db.db.Delete(key, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error deleting key from LevelDB: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Has checks if a key exists
func (db *LevelDBDatabase) Has(key []byte) (bool, error) <span class="cov8" title="1">{
        if !db.IsOpen() </span><span class="cov8" title="1">{
                return false, storage.NewStorageError(
                        storage.ErrDatabaseClosed,
                        "database is closed",
                        map[string]interface{}{"database": db.ID()},
                        nil,
                )
        }</span>

        <span class="cov8" title="1">exists, err := db.db.Has(key, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("error checking key existence in LevelDB: %w", err)
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

// Iterate iterates over all key-value pairs
func (db *LevelDBDatabase) Iterate(fn func(key, value []byte) bool) error <span class="cov8" title="1">{
        if !db.IsOpen() </span><span class="cov8" title="1">{
                return storage.NewStorageError(
                        storage.ErrDatabaseClosed,
                        "database is closed",
                        map[string]interface{}{"database": db.ID()},
                        nil,
                )
        }</span>

        <span class="cov8" title="1">iter := db.db.NewIterator(nil, nil)
        defer iter.Release()

        for iter.Next() </span><span class="cov8" title="1">{
                // Make copies of the key and value to prevent modification by the iterator
                key := make([]byte, len(iter.Key()))
                copy(key, iter.Key())

                value := make([]byte, len(iter.Value()))
                copy(value, iter.Value())

                if !fn(key, value) </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if err := iter.Error(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error during iteration: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IterateRange iterates over a range of key-value pairs
func (db *LevelDBDatabase) IterateRange(start, end []byte, ascending bool, fn func(key, value []byte) bool) error <span class="cov8" title="1">{
        if !db.IsOpen() </span><span class="cov0" title="0">{
                return storage.NewStorageError(
                        storage.ErrDatabaseClosed,
                        "database is closed",
                        map[string]interface{}{"database": db.ID()},
                        nil,
                )
        }</span>

        // Create range
        <span class="cov8" title="1">r := &amp;util.Range{Start: start, Limit: end}

        // If end is empty, don't limit the range
        if len(end) == 0 </span><span class="cov0" title="0">{
                r.Limit = nil
        }</span>

        // Create iterator with the specified range
        <span class="cov8" title="1">iter := db.db.NewIterator(r, nil)
        defer iter.Release()

        // Handle iteration order
        var processIterator func() bool

        if ascending </span><span class="cov8" title="1">{
                processIterator = func() bool </span><span class="cov8" title="1">{
                        return processSingleItem(iter, fn)
                }</span>
        } else<span class="cov8" title="1"> {
                // For descending order, collect all keys first, then iterate in reverse
                var keys [][]byte
                var values [][]byte

                for iter.Next() </span><span class="cov8" title="1">{
                        k := make([]byte, len(iter.Key()))
                        copy(k, iter.Key())

                        v := make([]byte, len(iter.Value()))
                        copy(v, iter.Value())

                        keys = append(keys, k)
                        values = append(values, v)
                }</span>

                // Check for errors before proceeding
                <span class="cov8" title="1">if err := iter.Error(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error during range iteration: %w", err)
                }</span>

                // Iterate in reverse
                <span class="cov8" title="1">processIterator = func() bool </span><span class="cov8" title="1">{
                        for i := len(keys) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                if !fn(keys[i], values[i]) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                        <span class="cov8" title="1">return true</span>
                }
        }

        // Process the iterator
        <span class="cov8" title="1">processIterator()

        return nil</span>
}

// Helper function to process a single iterator item
func processSingleItem(iter iterator.Iterator, fn func(key, value []byte) bool) bool <span class="cov8" title="1">{
        for iter.Next() </span><span class="cov8" title="1">{
                key := make([]byte, len(iter.Key()))
                copy(key, iter.Key())

                value := make([]byte, len(iter.Value()))
                copy(value, iter.Value())

                if !fn(key, value) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// SaveVersion saves the current state as a new version
func (db *LevelDBDatabase) SaveVersion() ([]byte, int64, error) <span class="cov8" title="1">{
        if !db.IsOpen() </span><span class="cov0" title="0">{
                return nil, 0, storage.NewStorageError(
                        storage.ErrDatabaseClosed,
                        "database is closed",
                        map[string]interface{}{"database": db.ID()},
                        nil,
                )
        }</span>

        <span class="cov8" title="1">db.mutex.Lock()
        defer db.mutex.Unlock()

        // Get the next version number
        nextVersion := db.Version() + 1

        // Create a snapshot of the database
        snapshot, err := db.db.GetSnapshot()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("error creating snapshot: %w", err)
        }</span>
        <span class="cov8" title="1">defer snapshot.Release()

        // Create a version file path
        versionFilePath := filepath.Join(db.versionPath, fmt.Sprintf("v%d.ldb", nextVersion))

        // Create a new LevelDB for this version
        options := &amp;opt.Options{
                BlockSize:              db.config.BlockSize,
                BlockCacheCapacity:     db.config.BlockCache,
                WriteBuffer:            db.config.WriteBufferSize,
                Filter:                 filter.NewBloomFilter(10),
                DisableSeeksCompaction: false,
        }

        versionDB, err := leveldb.OpenFile(versionFilePath, options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("error creating version database: %w", err)
        }</span>

        // Copy all data to the version database
        <span class="cov8" title="1">iter := snapshot.NewIterator(nil, nil)
        batch := new(leveldb.Batch)

        for iter.Next() </span><span class="cov8" title="1">{
                batch.Put(iter.Key(), iter.Value())

                // Write in batches to avoid memory issues with large databases
                if batch.Len() &gt;= 1000 </span><span class="cov0" title="0">{
                        if err := versionDB.Write(batch, nil); err != nil </span><span class="cov0" title="0">{
                                versionDB.Close()
                                iter.Release()
                                return nil, 0, fmt.Errorf("error writing batch to version database: %w", err)
                        }</span>
                        <span class="cov0" title="0">batch.Reset()</span>
                }
        }

        // Write any remaining batch items
        <span class="cov8" title="1">if batch.Len() &gt; 0 </span><span class="cov8" title="1">{
                if err := versionDB.Write(batch, nil); err != nil </span><span class="cov0" title="0">{
                        versionDB.Close()
                        iter.Release()
                        return nil, 0, fmt.Errorf("error writing final batch to version database: %w", err)
                }</span>
        }

        <span class="cov8" title="1">iter.Release()
        versionDB.Close()

        // Update the current version
        var buf [binary.MaxVarintLen64]byte
        n := binary.PutVarint(buf[:], nextVersion)

        if err := db.db.Put([]byte(versionKey), buf[:n], nil); err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("error updating version metadata: %w", err)
        }</span>

        // Update version in memory
        <span class="cov8" title="1">db.SetVersion(nextVersion)

        // Generate a root hash (in LevelDB we don't have a true Merkle root, so we use a placeholder)
        rootHash := []byte(fmt.Sprintf("leveldb-v%d", nextVersion))

        return rootHash, nextVersion, nil</span>
}

// LoadVersion loads a specific version
func (db *LevelDBDatabase) LoadVersion(targetVersion int64) (int64, error) <span class="cov0" title="0">{
        if !db.IsOpen() </span><span class="cov0" title="0">{
                return 0, storage.NewStorageError(
                        storage.ErrDatabaseClosed,
                        "database is closed",
                        map[string]interface{}{"database": db.ID()},
                        nil,
                )
        }</span>

        <span class="cov0" title="0">db.mutex.Lock()
        defer db.mutex.Unlock()

        // Check if the version exists
        versions := db.AvailableVersions()
        versionExists := false

        for _, v := range versions </span><span class="cov0" title="0">{
                if v == targetVersion </span><span class="cov0" title="0">{
                        versionExists = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !versionExists </span><span class="cov0" title="0">{
                return 0, storage.NewStorageError(
                        storage.ErrVersionNotFound,
                        "version not found",
                        map[string]interface{}{"version": targetVersion},
                        nil,
                )
        }</span>

        // Path to the version file
        <span class="cov0" title="0">versionFilePath := filepath.Join(db.versionPath, fmt.Sprintf("v%d.ldb", targetVersion))

        // Check if the version file exists
        if _, err := os.Stat(versionFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return 0, storage.NewStorageError(
                        storage.ErrVersionNotFound,
                        "version file not found",
                        map[string]interface{}{"version": targetVersion, "path": versionFilePath},
                        nil,
                )
        }</span>

        // Close the existing database
        <span class="cov0" title="0">if err := db.db.Close(); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("error closing current database: %w", err)
        }</span>

        // Open the version database
        <span class="cov0" title="0">options := &amp;opt.Options{
                BlockSize:              db.config.BlockSize,
                BlockCacheCapacity:     db.config.BlockCache,
                WriteBuffer:            db.config.WriteBufferSize,
                Filter:                 filter.NewBloomFilter(10),
                DisableSeeksCompaction: false,
        }

        versionDB, err := leveldb.OpenFile(versionFilePath, options)
        if err != nil </span><span class="cov0" title="0">{
                // Try to reopen the original database
                db.db, _ = leveldb.OpenFile(db.Path(), options)
                return 0, fmt.Errorf("error opening version database: %w", err)
        }</span>

        // Copy data from version database to main database
        <span class="cov0" title="0">mainDBPath := db.Path()
        tempDBPath := mainDBPath + ".temp"

        // Create a new temporary database
        tempDB, err := leveldb.OpenFile(tempDBPath, options)
        if err != nil </span><span class="cov0" title="0">{
                versionDB.Close()
                db.db, _ = leveldb.OpenFile(mainDBPath, options)
                return 0, fmt.Errorf("error creating temporary database: %w", err)
        }</span>

        // Copy all data from version DB to temp DB
        <span class="cov0" title="0">iter := versionDB.NewIterator(nil, nil)
        batch := new(leveldb.Batch)

        for iter.Next() </span><span class="cov0" title="0">{
                batch.Put(iter.Key(), iter.Value())

                // Write in batches to avoid memory issues with large databases
                if batch.Len() &gt;= 1000 </span><span class="cov0" title="0">{
                        if err := tempDB.Write(batch, nil); err != nil </span><span class="cov0" title="0">{
                                tempDB.Close()
                                versionDB.Close()
                                os.RemoveAll(tempDBPath)
                                db.db, _ = leveldb.OpenFile(mainDBPath, options)
                                return 0, fmt.Errorf("error writing batch to temporary database: %w", err)
                        }</span>
                        <span class="cov0" title="0">batch.Reset()</span>
                }
        }

        // Write any remaining batch items
        <span class="cov0" title="0">if batch.Len() &gt; 0 </span><span class="cov0" title="0">{
                if err := tempDB.Write(batch, nil); err != nil </span><span class="cov0" title="0">{
                        tempDB.Close()
                        versionDB.Close()
                        os.RemoveAll(tempDBPath)
                        db.db, _ = leveldb.OpenFile(mainDBPath, options)
                        return 0, fmt.Errorf("error writing final batch to temporary database: %w", err)
                }</span>
        }

        <span class="cov0" title="0">iter.Release()

        // Close databases
        tempDB.Close()
        versionDB.Close()

        // Replace main database with temporary database
        os.RemoveAll(mainDBPath)
        if err := os.Rename(tempDBPath, mainDBPath); err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(tempDBPath)
                db.db, _ = leveldb.OpenFile(mainDBPath, options)
                return 0, fmt.Errorf("error replacing main database: %w", err)
        }</span>

        // Open the new main database
        <span class="cov0" title="0">newDB, err := leveldb.OpenFile(mainDBPath, options)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("error opening new main database: %w", err)
        }</span>

        // Update the database reference
        <span class="cov0" title="0">db.db = newDB

        // Update the current version
        var buf [binary.MaxVarintLen64]byte
        n := binary.PutVarint(buf[:], targetVersion)

        if err := db.db.Put([]byte(versionKey), buf[:n], nil); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("error updating version metadata: %w", err)
        }</span>

        // Update version in memory
        <span class="cov0" title="0">db.SetVersion(targetVersion)

        return targetVersion, nil</span>
}

// AvailableVersions returns the list of available versions
func (db *LevelDBDatabase) AvailableVersions() []int64 <span class="cov8" title="1">{
        db.mutex.RLock()
        defer db.mutex.RUnlock()

        versions := []int64{db.Version()} // Current version is always available

        // Scan the version directory for available versions
        files, err := os.ReadDir(db.versionPath)
        if err != nil </span><span class="cov0" title="0">{
                return versions
        }</span>

        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                if file.IsDir() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov0" title="0">var version int64
                _, err := fmt.Sscanf(file.Name(), "v%d.ldb", &amp;version)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if version is already in the list
                <span class="cov0" title="0">found := false
                for _, v := range versions </span><span class="cov0" title="0">{
                        if v == version </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        versions = append(versions, version)
                }</span>
        }

        // Sort versions
        <span class="cov8" title="1">sort.Slice(versions, func(i, j int) bool </span><span class="cov0" title="0">{
                return versions[i] &lt; versions[j]
        }</span>)

        <span class="cov8" title="1">return versions</span>
}

// SupportTransactions returns whether this database supports transactions
func (db *LevelDBDatabase) SupportTransactions() bool <span class="cov8" title="1">{
        return true
}</span>

// BeginTransaction starts a new transaction
func (db *LevelDBDatabase) BeginTransaction() (storage.Transaction, error) <span class="cov8" title="1">{
        if !db.IsOpen() </span><span class="cov8" title="1">{
                return nil, storage.NewStorageError(
                        storage.ErrDatabaseClosed,
                        "database is closed",
                        map[string]interface{}{"database": db.ID()},
                        nil,
                )
        }</span>

        <span class="cov8" title="1">return NewLevelDBTransaction(db), nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package leveldb provides a LevelDB implementation of the storage interfaces.
package leveldb

import (
        "path/filepath"

        "github.com/ebanfa/skeleton-staging/internal/domain/component"
        "github.com/ebanfa/skeleton-staging/internal/domain/storage"
        "github.com/ebanfa/skeleton-staging/internal/infrastructure/storage/engine"
)

// LevelDBEngine provides a storage engine that uses LevelDB
type LevelDBEngine struct {
        *component.BaseComponent
}

// NewLevelDBEngine creates a new LevelDBEngine instance
func NewLevelDBEngine() *LevelDBEngine <span class="cov8" title="1">{
        return &amp;LevelDBEngine{
                BaseComponent: component.NewBaseComponent("leveldb-engine", "LevelDB Storage Engine", component.TypeSystem),
        }
}</span>

// CreateDatabase creates a new LevelDB database
func (e *LevelDBEngine) CreateDatabase(id, path string, options component.Metadata) (storage.Database, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, storage.NewStorageError(
                        storage.ErrDatabaseCreation,
                        "database ID cannot be empty",
                        nil,
                        nil,
                )
        }</span>

        // Clean path to ensure consistency
        <span class="cov8" title="1">cleanPath := filepath.Clean(path)

        // Set default LevelDB options if not provided
        if options == nil </span><span class="cov8" title="1">{
                options = make(component.Metadata)
        }</span>

        // Create LevelDB config from options
        <span class="cov8" title="1">config := engine.NewDefaultLevelDBConfig()
        if blockSize, ok := options["blockSize"].(int); ok &amp;&amp; blockSize &gt; 0 </span><span class="cov8" title="1">{
                config.BlockSize = blockSize
        }</span>
        <span class="cov8" title="1">if blockCache, ok := options["blockCache"].(int); ok &amp;&amp; blockCache &gt; 0 </span><span class="cov8" title="1">{
                config.BlockCache = blockCache
        }</span>
        <span class="cov8" title="1">if writeBufferSize, ok := options["writeBufferSize"].(int); ok &amp;&amp; writeBufferSize &gt; 0 </span><span class="cov0" title="0">{
                config.WriteBufferSize = writeBufferSize
        }</span>
        <span class="cov8" title="1">if disableCompression, ok := options["disableCompression"].(bool); ok </span><span class="cov0" title="0">{
                config.DisableCompression = disableCompression
        }</span>

        // Create the database
        <span class="cov8" title="1">db, err := NewLevelDBDatabase(id, "LevelDB Database: "+id, cleanPath, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, storage.NewStorageError(
                        storage.ErrDatabaseCreation,
                        "failed to create LevelDB database",
                        map[string]interface{}{
                                "id":   id,
                                "path": cleanPath,
                        },
                        err,
                )
        }</span>

        <span class="cov8" title="1">return db, nil</span>
}

// OpenDatabase opens an existing LevelDB database
func (e *LevelDBEngine) OpenDatabase(id, path string) (storage.Database, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, storage.NewStorageError(
                        storage.ErrDatabaseOpen,
                        "database ID cannot be empty",
                        nil,
                        nil,
                )
        }</span>

        // Clean path to ensure consistency
        <span class="cov8" title="1">cleanPath := filepath.Clean(path)

        // Open the database
        db, err := OpenLevelDBDatabase(id, "LevelDB Database: "+id, cleanPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, storage.NewStorageError(
                        storage.ErrDatabaseOpen,
                        "failed to open LevelDB database",
                        map[string]interface{}{
                                "id":   id,
                                "path": cleanPath,
                        },
                        err,
                )
        }</span>

        <span class="cov8" title="1">return db, nil</span>
}

// Capabilities returns the capabilities of this storage engine
func (e *LevelDBEngine) Capabilities() storage.StorageEngineCapabilities <span class="cov8" title="1">{
        return storage.StorageEngineCapabilities{
                SupportsTransactions: true,
                SupportsVersioning:   true,
                SupportsRangeQueries: true,
                SupportsBatchOps:     true,
                SupportsCompaction:   true,
                IsEmbedded:           true,
        }
}</span>

// Initialize initializes the LevelDB engine
func (e *LevelDBEngine) Initialize(ctx component.Context) error <span class="cov8" title="1">{
        return e.BaseComponent.Initialize(ctx)
}</span>

// Dispose releases all resources
func (e *LevelDBEngine) Dispose() error <span class="cov8" title="1">{
        return e.BaseComponent.Dispose()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package leveldb provides a LevelDB implementation of the storage interfaces.
package leveldb

import (
        "sync"

        "github.com/ebanfa/skeleton-staging/internal/domain/storage"
        "github.com/syndtr/goleveldb/leveldb"
)

// LevelDBTransaction implements the Transaction interface for LevelDB databases
type LevelDBTransaction struct {
        db        *LevelDBDatabase
        data      map[string][]byte
        deleted   map[string]bool
        committed bool
        mutex     sync.RWMutex
}

// NewLevelDBTransaction creates a new LevelDB transaction
func NewLevelDBTransaction(db *LevelDBDatabase) *LevelDBTransaction <span class="cov8" title="1">{
        return &amp;LevelDBTransaction{
                db:        db,
                data:      make(map[string][]byte),
                deleted:   make(map[string]bool),
                committed: false,
        }
}</span>

// Get retrieves a value from the transaction
func (tx *LevelDBTransaction) Get(key []byte) ([]byte, error) <span class="cov8" title="1">{
        if tx.committed </span><span class="cov8" title="1">{
                return nil, storage.NewStorageError(
                        storage.ErrTransactionFailed,
                        "transaction already committed or rolled back",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">if key == nil || len(key) == 0 </span><span class="cov0" title="0">{
                return nil, storage.NewStorageError(
                        storage.ErrInvalidKey,
                        "key cannot be nil or empty",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">tx.mutex.RLock()
        defer tx.mutex.RUnlock()

        strKey := string(key)

        // Check if the key was deleted in this transaction
        if tx.deleted[strKey] </span><span class="cov8" title="1">{
                return nil, storage.NewStorageError(
                        storage.ErrKeyNotFound,
                        "key not found",
                        map[string]interface{}{"key": strKey},
                        nil,
                )
        }</span>

        // Check if the key was updated in this transaction
        <span class="cov8" title="1">if value, exists := tx.data[strKey]; exists </span><span class="cov8" title="1">{
                result := make([]byte, len(value))
                copy(result, value)
                return result, nil
        }</span>

        // Otherwise, get from the underlying database
        <span class="cov8" title="1">return tx.db.Get(key)</span>
}

// Set stores a key-value pair in the transaction
func (tx *LevelDBTransaction) Set(key, value []byte) error <span class="cov8" title="1">{
        if tx.committed </span><span class="cov8" title="1">{
                return storage.NewStorageError(
                        storage.ErrTransactionFailed,
                        "transaction already committed or rolled back",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">if key == nil || len(key) == 0 </span><span class="cov8" title="1">{
                return storage.NewStorageError(
                        storage.ErrInvalidKey,
                        "key cannot be nil or empty",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">if value == nil </span><span class="cov8" title="1">{
                return storage.NewStorageError(
                        storage.ErrInvalidValue,
                        "value cannot be nil",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">tx.mutex.Lock()
        defer tx.mutex.Unlock()

        strKey := string(key)

        // Remove from deleted keys if it was deleted earlier in this transaction
        delete(tx.deleted, strKey)

        // Store a copy to prevent modification of the input data
        valueData := make([]byte, len(value))
        copy(valueData, value)

        // Store in transaction data
        tx.data[strKey] = valueData

        return nil</span>
}

// Delete removes a key-value pair from the transaction
func (tx *LevelDBTransaction) Delete(key []byte) error <span class="cov8" title="1">{
        if tx.committed </span><span class="cov8" title="1">{
                return storage.NewStorageError(
                        storage.ErrTransactionFailed,
                        "transaction already committed or rolled back",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">if key == nil || len(key) == 0 </span><span class="cov0" title="0">{
                return storage.NewStorageError(
                        storage.ErrInvalidKey,
                        "key cannot be nil or empty",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">tx.mutex.Lock()
        defer tx.mutex.Unlock()

        strKey := string(key)

        // Mark as deleted
        tx.deleted[strKey] = true

        // Remove from transaction data if it was set earlier
        delete(tx.data, strKey)

        return nil</span>
}

// Commit applies all changes to the underlying database
func (tx *LevelDBTransaction) Commit() error <span class="cov8" title="1">{
        if tx.committed </span><span class="cov8" title="1">{
                return storage.NewStorageError(
                        storage.ErrTransactionFailed,
                        "transaction already committed or rolled back",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">tx.mutex.Lock()
        defer tx.mutex.Unlock()

        // Use LevelDB batch for atomicity
        batch := new(leveldb.Batch)

        // Apply changes to the batch
        for key, value := range tx.data </span><span class="cov8" title="1">{
                batch.Put([]byte(key), value)
        }</span>

        // Apply deletions to the batch
        <span class="cov8" title="1">for key := range tx.deleted </span><span class="cov8" title="1">{
                batch.Delete([]byte(key))
        }</span>

        // Acquire database lock to apply batch
        <span class="cov8" title="1">tx.db.mutex.Lock()
        defer tx.db.mutex.Unlock()

        // Apply the batch to the database
        if err := tx.db.db.Write(batch, nil); err != nil </span><span class="cov0" title="0">{
                return storage.NewStorageError(
                        storage.ErrTransactionFailed,
                        "failed to commit transaction",
                        nil,
                        err,
                )
        }</span>

        // Mark as committed
        <span class="cov8" title="1">tx.committed = true
        tx.data = nil
        tx.deleted = nil

        return nil</span>
}

// Rollback discards all transaction changes
func (tx *LevelDBTransaction) Rollback() error <span class="cov8" title="1">{
        if tx.committed </span><span class="cov8" title="1">{
                return storage.NewStorageError(
                        storage.ErrTransactionFailed,
                        "transaction already committed or rolled back",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">tx.mutex.Lock()
        defer tx.mutex.Unlock()

        // Just mark as committed (rolled back) and clear the maps
        tx.committed = true
        tx.data = nil
        tx.deleted = nil

        return nil</span>
}

// Has checks if a key exists
func (tx *LevelDBTransaction) Has(key []byte) (bool, error) <span class="cov8" title="1">{
        if tx.committed </span><span class="cov0" title="0">{
                return false, storage.NewStorageError(
                        storage.ErrTransactionFailed,
                        "transaction already committed or rolled back",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">if key == nil || len(key) == 0 </span><span class="cov0" title="0">{
                return false, storage.NewStorageError(
                        storage.ErrInvalidKey,
                        "key cannot be nil or empty",
                        nil,
                        nil,
                )
        }</span>

        <span class="cov8" title="1">tx.mutex.RLock()
        defer tx.mutex.RUnlock()

        strKey := string(key)

        // Check if the key was deleted in this transaction
        if tx.deleted[strKey] </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // Check if the key was set in this transaction
        <span class="cov8" title="1">if _, exists := tx.data[strKey]; exists </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // Otherwise, check the underlying database
        <span class="cov8" title="1">return tx.db.Has(key)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
