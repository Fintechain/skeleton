// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"github.com/fintechain/skeleton/internal/domain/component"
	"github.com/fintechain/skeleton/internal/domain/config"
	"github.com/fintechain/skeleton/internal/domain/context"
	"github.com/fintechain/skeleton/internal/domain/event"
	"github.com/fintechain/skeleton/internal/domain/logging"
	"github.com/fintechain/skeleton/internal/domain/plugin"
	mock "github.com/stretchr/testify/mock"
)

// NewMockRuntimeEnvironment creates a new instance of MockRuntimeEnvironment. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRuntimeEnvironment(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRuntimeEnvironment {
	mock := &MockRuntimeEnvironment{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRuntimeEnvironment is an autogenerated mock type for the RuntimeEnvironment type
type MockRuntimeEnvironment struct {
	mock.Mock
}

type MockRuntimeEnvironment_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRuntimeEnvironment) EXPECT() *MockRuntimeEnvironment_Expecter {
	return &MockRuntimeEnvironment_Expecter{mock: &_m.Mock}
}

// Configuration provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) Configuration() config.Configuration {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Configuration")
	}

	var r0 config.Configuration
	if returnFunc, ok := ret.Get(0).(func() config.Configuration); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(config.Configuration)
		}
	}
	return r0
}

// MockRuntimeEnvironment_Configuration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Configuration'
type MockRuntimeEnvironment_Configuration_Call struct {
	*mock.Call
}

// Configuration is a helper method to define mock.On call
func (_e *MockRuntimeEnvironment_Expecter) Configuration() *MockRuntimeEnvironment_Configuration_Call {
	return &MockRuntimeEnvironment_Configuration_Call{Call: _e.mock.On("Configuration")}
}

func (_c *MockRuntimeEnvironment_Configuration_Call) Run(run func()) *MockRuntimeEnvironment_Configuration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRuntimeEnvironment_Configuration_Call) Return(configuration config.Configuration) *MockRuntimeEnvironment_Configuration_Call {
	_c.Call.Return(configuration)
	return _c
}

func (_c *MockRuntimeEnvironment_Configuration_Call) RunAndReturn(run func() config.Configuration) *MockRuntimeEnvironment_Configuration_Call {
	_c.Call.Return(run)
	return _c
}

// EventBus provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) EventBus() event.EventBusService {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EventBus")
	}

	var r0 event.EventBusService
	if returnFunc, ok := ret.Get(0).(func() event.EventBusService); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.EventBusService)
		}
	}
	return r0
}

// MockRuntimeEnvironment_EventBus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EventBus'
type MockRuntimeEnvironment_EventBus_Call struct {
	*mock.Call
}

// EventBus is a helper method to define mock.On call
func (_e *MockRuntimeEnvironment_Expecter) EventBus() *MockRuntimeEnvironment_EventBus_Call {
	return &MockRuntimeEnvironment_EventBus_Call{Call: _e.mock.On("EventBus")}
}

func (_c *MockRuntimeEnvironment_EventBus_Call) Run(run func()) *MockRuntimeEnvironment_EventBus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRuntimeEnvironment_EventBus_Call) Return(eventBusService event.EventBusService) *MockRuntimeEnvironment_EventBus_Call {
	_c.Call.Return(eventBusService)
	return _c
}

func (_c *MockRuntimeEnvironment_EventBus_Call) RunAndReturn(run func() event.EventBusService) *MockRuntimeEnvironment_EventBus_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteOperation provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) ExecuteOperation(ctx context.Context, operationID component.ComponentID, input component.Input) (component.Output, error) {
	ret := _mock.Called(ctx, operationID, input)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteOperation")
	}

	var r0 component.Output
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, component.ComponentID, component.Input) (component.Output, error)); ok {
		return returnFunc(ctx, operationID, input)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, component.ComponentID, component.Input) component.Output); ok {
		r0 = returnFunc(ctx, operationID, input)
	} else {
		r0 = ret.Get(0).(component.Output)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, component.ComponentID, component.Input) error); ok {
		r1 = returnFunc(ctx, operationID, input)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRuntimeEnvironment_ExecuteOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteOperation'
type MockRuntimeEnvironment_ExecuteOperation_Call struct {
	*mock.Call
}

// ExecuteOperation is a helper method to define mock.On call
//   - ctx context.Context
//   - operationID component.ComponentID
//   - input component.Input
func (_e *MockRuntimeEnvironment_Expecter) ExecuteOperation(ctx interface{}, operationID interface{}, input interface{}) *MockRuntimeEnvironment_ExecuteOperation_Call {
	return &MockRuntimeEnvironment_ExecuteOperation_Call{Call: _e.mock.On("ExecuteOperation", ctx, operationID, input)}
}

func (_c *MockRuntimeEnvironment_ExecuteOperation_Call) Run(run func(ctx context.Context, operationID component.ComponentID, input component.Input)) *MockRuntimeEnvironment_ExecuteOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 component.ComponentID
		if args[1] != nil {
			arg1 = args[1].(component.ComponentID)
		}
		var arg2 component.Input
		if args[2] != nil {
			arg2 = args[2].(component.Input)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRuntimeEnvironment_ExecuteOperation_Call) Return(output component.Output, err error) *MockRuntimeEnvironment_ExecuteOperation_Call {
	_c.Call.Return(output, err)
	return _c
}

func (_c *MockRuntimeEnvironment_ExecuteOperation_Call) RunAndReturn(run func(ctx context.Context, operationID component.ComponentID, input component.Input) (component.Output, error)) *MockRuntimeEnvironment_ExecuteOperation_Call {
	_c.Call.Return(run)
	return _c
}

// IsRunning provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) IsRunning() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsRunning")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockRuntimeEnvironment_IsRunning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsRunning'
type MockRuntimeEnvironment_IsRunning_Call struct {
	*mock.Call
}

// IsRunning is a helper method to define mock.On call
func (_e *MockRuntimeEnvironment_Expecter) IsRunning() *MockRuntimeEnvironment_IsRunning_Call {
	return &MockRuntimeEnvironment_IsRunning_Call{Call: _e.mock.On("IsRunning")}
}

func (_c *MockRuntimeEnvironment_IsRunning_Call) Run(run func()) *MockRuntimeEnvironment_IsRunning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRuntimeEnvironment_IsRunning_Call) Return(b bool) *MockRuntimeEnvironment_IsRunning_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockRuntimeEnvironment_IsRunning_Call) RunAndReturn(run func() bool) *MockRuntimeEnvironment_IsRunning_Call {
	_c.Call.Return(run)
	return _c
}

// LoadPlugins provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) LoadPlugins(ctx context.Context, plugins []plugin.Plugin) error {
	ret := _mock.Called(ctx, plugins)

	if len(ret) == 0 {
		panic("no return value specified for LoadPlugins")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []plugin.Plugin) error); ok {
		r0 = returnFunc(ctx, plugins)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRuntimeEnvironment_LoadPlugins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadPlugins'
type MockRuntimeEnvironment_LoadPlugins_Call struct {
	*mock.Call
}

// LoadPlugins is a helper method to define mock.On call
//   - ctx context.Context
//   - plugins []plugin.Plugin
func (_e *MockRuntimeEnvironment_Expecter) LoadPlugins(ctx interface{}, plugins interface{}) *MockRuntimeEnvironment_LoadPlugins_Call {
	return &MockRuntimeEnvironment_LoadPlugins_Call{Call: _e.mock.On("LoadPlugins", ctx, plugins)}
}

func (_c *MockRuntimeEnvironment_LoadPlugins_Call) Run(run func(ctx context.Context, plugins []plugin.Plugin)) *MockRuntimeEnvironment_LoadPlugins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []plugin.Plugin
		if args[1] != nil {
			arg1 = args[1].([]plugin.Plugin)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRuntimeEnvironment_LoadPlugins_Call) Return(err error) *MockRuntimeEnvironment_LoadPlugins_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRuntimeEnvironment_LoadPlugins_Call) RunAndReturn(run func(ctx context.Context, plugins []plugin.Plugin) error) *MockRuntimeEnvironment_LoadPlugins_Call {
	_c.Call.Return(run)
	return _c
}

// Logger provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) Logger() logging.Logger {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Logger")
	}

	var r0 logging.Logger
	if returnFunc, ok := ret.Get(0).(func() logging.Logger); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(logging.Logger)
		}
	}
	return r0
}

// MockRuntimeEnvironment_Logger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logger'
type MockRuntimeEnvironment_Logger_Call struct {
	*mock.Call
}

// Logger is a helper method to define mock.On call
func (_e *MockRuntimeEnvironment_Expecter) Logger() *MockRuntimeEnvironment_Logger_Call {
	return &MockRuntimeEnvironment_Logger_Call{Call: _e.mock.On("Logger")}
}

func (_c *MockRuntimeEnvironment_Logger_Call) Run(run func()) *MockRuntimeEnvironment_Logger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRuntimeEnvironment_Logger_Call) Return(logger logging.Logger) *MockRuntimeEnvironment_Logger_Call {
	_c.Call.Return(logger)
	return _c
}

func (_c *MockRuntimeEnvironment_Logger_Call) RunAndReturn(run func() logging.Logger) *MockRuntimeEnvironment_Logger_Call {
	_c.Call.Return(run)
	return _c
}

// PluginManager provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) PluginManager() plugin.PluginManager {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for PluginManager")
	}

	var r0 plugin.PluginManager
	if returnFunc, ok := ret.Get(0).(func() plugin.PluginManager); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(plugin.PluginManager)
		}
	}
	return r0
}

// MockRuntimeEnvironment_PluginManager_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PluginManager'
type MockRuntimeEnvironment_PluginManager_Call struct {
	*mock.Call
}

// PluginManager is a helper method to define mock.On call
func (_e *MockRuntimeEnvironment_Expecter) PluginManager() *MockRuntimeEnvironment_PluginManager_Call {
	return &MockRuntimeEnvironment_PluginManager_Call{Call: _e.mock.On("PluginManager")}
}

func (_c *MockRuntimeEnvironment_PluginManager_Call) Run(run func()) *MockRuntimeEnvironment_PluginManager_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRuntimeEnvironment_PluginManager_Call) Return(pluginManager plugin.PluginManager) *MockRuntimeEnvironment_PluginManager_Call {
	_c.Call.Return(pluginManager)
	return _c
}

func (_c *MockRuntimeEnvironment_PluginManager_Call) RunAndReturn(run func() plugin.PluginManager) *MockRuntimeEnvironment_PluginManager_Call {
	_c.Call.Return(run)
	return _c
}

// Registry provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) Registry() component.Registry {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Registry")
	}

	var r0 component.Registry
	if returnFunc, ok := ret.Get(0).(func() component.Registry); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(component.Registry)
		}
	}
	return r0
}

// MockRuntimeEnvironment_Registry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Registry'
type MockRuntimeEnvironment_Registry_Call struct {
	*mock.Call
}

// Registry is a helper method to define mock.On call
func (_e *MockRuntimeEnvironment_Expecter) Registry() *MockRuntimeEnvironment_Registry_Call {
	return &MockRuntimeEnvironment_Registry_Call{Call: _e.mock.On("Registry")}
}

func (_c *MockRuntimeEnvironment_Registry_Call) Run(run func()) *MockRuntimeEnvironment_Registry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRuntimeEnvironment_Registry_Call) Return(registry component.Registry) *MockRuntimeEnvironment_Registry_Call {
	_c.Call.Return(registry)
	return _c
}

func (_c *MockRuntimeEnvironment_Registry_Call) RunAndReturn(run func() component.Registry) *MockRuntimeEnvironment_Registry_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) Start(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRuntimeEnvironment_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type MockRuntimeEnvironment_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRuntimeEnvironment_Expecter) Start(ctx interface{}) *MockRuntimeEnvironment_Start_Call {
	return &MockRuntimeEnvironment_Start_Call{Call: _e.mock.On("Start", ctx)}
}

func (_c *MockRuntimeEnvironment_Start_Call) Run(run func(ctx context.Context)) *MockRuntimeEnvironment_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockRuntimeEnvironment_Start_Call) Return(err error) *MockRuntimeEnvironment_Start_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRuntimeEnvironment_Start_Call) RunAndReturn(run func(ctx context.Context) error) *MockRuntimeEnvironment_Start_Call {
	_c.Call.Return(run)
	return _c
}

// StartService provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) StartService(ctx context.Context, serviceID component.ComponentID) error {
	ret := _mock.Called(ctx, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for StartService")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, component.ComponentID) error); ok {
		r0 = returnFunc(ctx, serviceID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRuntimeEnvironment_StartService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartService'
type MockRuntimeEnvironment_StartService_Call struct {
	*mock.Call
}

// StartService is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID component.ComponentID
func (_e *MockRuntimeEnvironment_Expecter) StartService(ctx interface{}, serviceID interface{}) *MockRuntimeEnvironment_StartService_Call {
	return &MockRuntimeEnvironment_StartService_Call{Call: _e.mock.On("StartService", ctx, serviceID)}
}

func (_c *MockRuntimeEnvironment_StartService_Call) Run(run func(ctx context.Context, serviceID component.ComponentID)) *MockRuntimeEnvironment_StartService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 component.ComponentID
		if args[1] != nil {
			arg1 = args[1].(component.ComponentID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRuntimeEnvironment_StartService_Call) Return(err error) *MockRuntimeEnvironment_StartService_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRuntimeEnvironment_StartService_Call) RunAndReturn(run func(ctx context.Context, serviceID component.ComponentID) error) *MockRuntimeEnvironment_StartService_Call {
	_c.Call.Return(run)
	return _c
}

// Stop provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) Stop(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRuntimeEnvironment_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type MockRuntimeEnvironment_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRuntimeEnvironment_Expecter) Stop(ctx interface{}) *MockRuntimeEnvironment_Stop_Call {
	return &MockRuntimeEnvironment_Stop_Call{Call: _e.mock.On("Stop", ctx)}
}

func (_c *MockRuntimeEnvironment_Stop_Call) Run(run func(ctx context.Context)) *MockRuntimeEnvironment_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockRuntimeEnvironment_Stop_Call) Return(err error) *MockRuntimeEnvironment_Stop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRuntimeEnvironment_Stop_Call) RunAndReturn(run func(ctx context.Context) error) *MockRuntimeEnvironment_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// StopService provides a mock function for the type MockRuntimeEnvironment
func (_mock *MockRuntimeEnvironment) StopService(ctx context.Context, serviceID component.ComponentID) error {
	ret := _mock.Called(ctx, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for StopService")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, component.ComponentID) error); ok {
		r0 = returnFunc(ctx, serviceID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRuntimeEnvironment_StopService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopService'
type MockRuntimeEnvironment_StopService_Call struct {
	*mock.Call
}

// StopService is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID component.ComponentID
func (_e *MockRuntimeEnvironment_Expecter) StopService(ctx interface{}, serviceID interface{}) *MockRuntimeEnvironment_StopService_Call {
	return &MockRuntimeEnvironment_StopService_Call{Call: _e.mock.On("StopService", ctx, serviceID)}
}

func (_c *MockRuntimeEnvironment_StopService_Call) Run(run func(ctx context.Context, serviceID component.ComponentID)) *MockRuntimeEnvironment_StopService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 component.ComponentID
		if args[1] != nil {
			arg1 = args[1].(component.ComponentID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRuntimeEnvironment_StopService_Call) Return(err error) *MockRuntimeEnvironment_StopService_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRuntimeEnvironment_StopService_Call) RunAndReturn(run func(ctx context.Context, serviceID component.ComponentID) error) *MockRuntimeEnvironment_StopService_Call {
	_c.Call.Return(run)
	return _c
}
